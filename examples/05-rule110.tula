let Cells { . # }

case Entry & & -> I

for a     in Cells case I       a a -> (I a)
for a b   in Cells case (I a)   b b -> (I a b)
for a b c in Cells case (I a b) c c <- (R a b c)
for a b   in Cells case (I a b) & & .  Print

case Print  & & !  Skip
case Skip   & & <- Reset
for a in Cells case Reset a a <- Reset
case Reset & & -> I

for _ in Cells {
    case (R . . .) _ . -> (I .)
    case (R . . #) _ # -> (I .)
    case (R . # .) _ # -> (I #)
    case (R . # #) _ # -> (I #)
    case (R # . .) _ . -> (I .)
    case (R # . #) _ # -> (I .)
    case (R # # .) _ # -> (I #)
    case (R # # #) _ . -> (I #)
}

// TODO: how to limit the amount of iterations
run Entry { & . . . . . . . . . . . . . . . # . & }
